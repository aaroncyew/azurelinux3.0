From eb53e76bfb5b04a981c6c4e9218ca1db9c9d2222 Mon Sep 17 00:00:00 2001
From: Sam Meluch <sammeluch@microsoft.com>
Date: Tue, 30 Apr 2024 13:56:44 -0700
Subject: [PATCH] Add virtual repo snapshot feature to tdnf

---
 client/config.c                            |   5 +
 client/prototypes.h                        |   3 +-
 client/repo.c                              |  50 +-
 common/config.h                            |   1 +
 etc/bash_completion.d/tdnf-completion.bash |   2 +-
 include/tdnferror.h                        |   9 +
 include/tdnftypes.h                        |   2 +
 solv/defines.h                             |  28 +
 solv/includes.h                            |   6 +-
 solv/prototypes.h                          |   3 +-
 solv/tdnfrepo.c                            | 656 ++++++++++++++++++++-
 tools/cli/lib/help.c                       |   1 +
 tools/cli/lib/parseargs.c                  |   1 +
 13 files changed, 750 insertions(+), 17 deletions(-)

diff --git a/client/config.c b/client/config.c
index 8ddcc7a..3d7b8d9 100644
--- a/client/config.c
+++ b/client/config.c
@@ -85,6 +85,7 @@ TDNFReadConfig(
     pConf->nInstallOnlyLimit = 1;
     pConf->nCleanRequirementsOnRemove = 0;
     pConf->nKeepCache = 0;
+    pConf->pszRepoEpochTimeLimit = NULL;
     pConf->nOpenMax = TDNF_DEFAULT_OPENMAX;
 
     register_ini(NULL);
@@ -122,6 +123,10 @@ TDNFReadConfig(
         {
             pConf->nInstallOnlyLimit = atoi(cn->value);
         }
+        else if (strcmp(cn->name, TDNF_CONF_KEY_EPOCH_TIME_LIMIT) == 0)
+        {
+            pConf->pszRepoEpochTimeLimit = cn->value; //assumes your system's time_t is typedef long
+        }
         else if (strcmp(cn->name, TDNF_CONF_KEY_CLEAN_REQ_ON_REMOVE) == 0)
         {
             pConf->nCleanRequirementsOnRemove = isTrue(cn->value);
diff --git a/client/prototypes.h b/client/prototypes.h
index bb7fba1..da1d374 100644
--- a/client/prototypes.h
+++ b/client/prototypes.h
@@ -586,7 +586,8 @@ uint32_t
 TDNFInitRepoFromMetadata(
     Repo *pRepo,
     const char* pszRepoName,
-    PTDNF_REPO_METADATA pRepoMD
+    PTDNF_REPO_METADATA pRepoMD,
+    char * pszRepoEpochLimit
     );
 
 uint32_t
diff --git a/client/repo.c b/client/repo.c
index b6073e2..0c1958b 100644
--- a/client/repo.c
+++ b/client/repo.c
@@ -36,6 +36,8 @@ TDNFInitRepo(
     Pool* pPool = NULL;
     int nUseMetaDataCache = 0;
     PSOLV_REPO_INFO_INTERNAL pSolvRepoInfo = NULL;
+    PTDNF_CMD_OPT pSetOpt = NULL;
+    char * pszRepoEpochTimeLimit = NULL;
 
     if (!pTdnf || !pRepoData || !pSack || !pSack->pPool)
     {
@@ -43,6 +45,21 @@ TDNFInitRepo(
         BAIL_ON_TDNF_ERROR(dwError);
     }
 
+    // set local epoch limit if conf or cmd line opt is present
+    if (pTdnf->pConf != NULL && pTdnf->pConf->pszRepoEpochTimeLimit != NULL) 
+    {
+        pszRepoEpochTimeLimit = pTdnf->pConf->pszRepoEpochTimeLimit;
+    }
+
+    // take command line over config if both are present
+    for (pSetOpt = pTdnf->pArgs->pSetOpt; pSetOpt; pSetOpt = pSetOpt->pNext) 
+    {
+        if(strncmp(pSetOpt->pszOptName, TDNF_CONF_KEY_EPOCH_TIME_LIMIT, strlen(TDNF_CONF_KEY_EPOCH_TIME_LIMIT)) == 0)
+        {
+            pszRepoEpochTimeLimit = pSetOpt->pszOptValue;
+        }
+    }
+
     pPool = pSack->pPool;
 
     dwError = TDNFGetCachePath(pTdnf, pRepoData,
@@ -82,20 +99,27 @@ TDNFInitRepo(
     pRepo->appdata = pSolvRepoInfo;
 
     if (pRepoData->nHasMetaData) {
-        dwError = SolvCalculateCookieForFile(pRepoMD->pszRepoMD, pSolvRepoInfo->cookie);
-        BAIL_ON_TDNF_ERROR(dwError);
-        pSolvRepoInfo->nCookieSet = 1;
-
-        dwError = SolvUseMetaDataCache(pSack, pSolvRepoInfo, &nUseMetaDataCache);
-        BAIL_ON_TDNF_ERROR(dwError);
-
-        if (nUseMetaDataCache == 0) {
-            dwError = TDNFInitRepoFromMetadata(pRepo, pRepoData->pszId, pRepoMD);
+        if (pszRepoEpochTimeLimit != NULL) {
+            dwError = TDNFInitRepoFromMetadata(pRepo, pRepoData->pszId, pRepoMD, pszRepoEpochTimeLimit);
             BAIL_ON_TDNF_ERROR(dwError);
+        } else {
+            dwError = SolvCalculateCookieForFile(pRepoMD->pszRepoMD, pSolvRepoInfo->cookie);
+            BAIL_ON_TDNF_ERROR(dwError);
+            pSolvRepoInfo->nCookieSet = 1;
 
-            dwError = SolvCreateMetaDataCache(pSack, pSolvRepoInfo);
+            dwError = SolvUseMetaDataCache(pSack, pSolvRepoInfo, &nUseMetaDataCache);
             BAIL_ON_TDNF_ERROR(dwError);
+
+            //force load from repo if epoch time limit is present
+            if (nUseMetaDataCache == 0) {
+                dwError = TDNFInitRepoFromMetadata(pRepo, pRepoData->pszId, pRepoMD, NULL);
+                BAIL_ON_TDNF_ERROR(dwError);
+
+                dwError = SolvCreateMetaDataCache(pSack, pSolvRepoInfo);
+                BAIL_ON_TDNF_ERROR(dwError);
+            }
         }
+        
     } else {
         dwError = SolvReadRpmsFromDirectory(pRepo, pRepoData->ppszBaseUrls[0]);
         BAIL_ON_TDNF_ERROR(dwError);
@@ -135,7 +159,8 @@ uint32_t
 TDNFInitRepoFromMetadata(
     Repo *pRepo,
     const char* pszRepoName,
-    PTDNF_REPO_METADATA pRepoMD
+    PTDNF_REPO_METADATA pRepoMD,
+    char * pszRepoEpochLimit
     )
 {
     uint32_t dwError = 0;
@@ -152,7 +177,8 @@ TDNFInitRepoFromMetadata(
                   pRepoMD->pszPrimary,
                   pRepoMD->pszFileLists,
                   pRepoMD->pszUpdateInfo,
-                  pRepoMD->pszOther);
+                  pRepoMD->pszOther,
+                  pszRepoEpochLimit);
 cleanup:
     return dwError;
 
diff --git a/common/config.h b/common/config.h
index 222a448..1370c0d 100644
--- a/common/config.h
+++ b/common/config.h
@@ -19,6 +19,7 @@
 //Conf file key names
 #define TDNF_CONF_KEY_GPGCHECK            "gpgcheck"
 #define TDNF_CONF_KEY_INSTALLONLY_LIMIT   "installonly_limit"
+#define TDNF_CONF_KEY_EPOCH_TIME_LIMIT    "epochtimelimit"
 #define TDNF_CONF_KEY_CLEAN_REQ_ON_REMOVE "clean_requirements_on_remove"
 #define TDNF_CONF_KEY_REPODIR             "repodir" // typo, keep for back compatibility
 #define TDNF_CONF_KEY_REPOSDIR            "reposdir"
diff --git a/etc/bash_completion.d/tdnf-completion.bash b/etc/bash_completion.d/tdnf-completion.bash
index 4e48040..285add2 100644
--- a/etc/bash_completion.d/tdnf-completion.bash
+++ b/etc/bash_completion.d/tdnf-completion.bash
@@ -92,7 +92,7 @@ _tdnf()
 {
     local c=0 cur __opts __cmds
     COMPREPLY=()
-    __opts="--assumeno --assumeyes --cacheonly --debugsolver --disableexcludes --disableplugin --disablerepo --downloaddir --downloadonly --enablerepo --enableplugin --exclude --installroot --noautoremove --nogpgcheck --noplugins --quiet --reboot --refresh --releasever --repo --repofrompath --repoid --rpmverbosity --security --sec --setopt --skip --skipconflicts --skipdigest --skipsignature --skipobsoletes --testonly --version --available --duplicates --extras --file --installed --whatdepends --whatrequires --whatenhances --whatobsoletes --whatprovides --whatrecommends --whatrequires --whatsuggests --whatsupplements --depends --enhances --list --obsoletes --provides --recommends --requires --requires --suggests --source --supplements --arch --delete --download --download --gpgcheck --metadata --newest --norepopath --source --urls"
+    __opts="--assumeno --assumeyes --cacheonly --debugsolver --disableexcludes --disableplugin --disablerepo --downloaddir --downloadonly --enablerepo --enableplugin --epochtimelimit --exclude --installroot --noautoremove --nogpgcheck --noplugins --quiet --reboot --refresh --releasever --repo --repofrompath --repoid --rpmverbosity --security --sec --setopt --skip --skipconflicts --skipdigest --skipsignature --skipobsoletes --testonly --version --available --duplicates --extras --file --installed --whatdepends --whatrequires --whatenhances --whatobsoletes --whatprovides --whatrecommends --whatrequires --whatsuggests --whatsupplements --depends --enhances --list --obsoletes --provides --recommends --requires --requires --suggests --source --supplements --arch --delete --download --download --gpgcheck --metadata --newest --norepopath --source --urls"
     __cmds="autoerase autoremove check check-local check-update clean distro-sync downgrade erase help history info install list makecache mark provides whatprovides reinstall remove repolist repoquery reposync search update update-to updateinfo upgrade upgrade-to"
     cur="${COMP_WORDS[COMP_CWORD]}"
     _tdnf__process_if_prev_is_option && return 0
diff --git a/include/tdnferror.h b/include/tdnferror.h
index c9349a0..02b8d4c 100644
--- a/include/tdnferror.h
+++ b/include/tdnferror.h
@@ -187,6 +187,15 @@ extern "C" {
 #define ERROR_TDNF_HISTORY_ERROR 1801
 #define ERROR_TDNF_HISTORY_NODB 1802
 
+#define ERROR_TDNF_TIME_FILTER_BASE 1900
+// filter MEMORY
+#define ERROR_TDNF_TIME_FILTER_MEMORY        (ERROR_TDNF_TIME_FILTER_BASE + 1)
+// filter parsing error
+#define ERROR_TDNF_TIME_FILTER_PARSE         (ERROR_TDNF_TIME_FILTER_BASE + 2)
+// filter IO error
+#define ERROR_TDNF_TIME_FILTER_IO            (ERROR_TDNF_TIME_FILTER_BASE + 3)
+// filter general error
+# define ERROR_TDNF_TIME_FILTER_GENERAL      (ERROR_TDNF_TIME_FILTER_BASE + 4)
 
 #define ERROR_TDNF_PLUGIN_BASE          2000
 
diff --git a/include/tdnftypes.h b/include/tdnftypes.h
index a806010..e638427 100644
--- a/include/tdnftypes.h
+++ b/include/tdnftypes.h
@@ -9,6 +9,7 @@
 #pragma once
 
 #include <curl/curl.h>
+#include <time.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -257,6 +258,7 @@ typedef struct _TDNF_CONF
     int nCheckUpdateCompat;
     int nDistroSyncReinstallChanged;
     char* pszRepoDir;
+    char* pszRepoEpochTimeLimit;
     char* pszCacheDir;
     char* pszPersistDir;
     char* pszProxy;
diff --git a/solv/defines.h b/solv/defines.h
index 38f5ab1..ebc7bd0 100644
--- a/solv/defines.h
+++ b/solv/defines.h
@@ -18,4 +18,32 @@
         }                                                          \
     } while(0)
 
+typedef struct {
+    // frequently changed values
+    char * pszElementBuffer;
+    int nBufferLen;
+    int nInPackage;
+    int nPrintPackage;
+    int nTimeFound;
+
+    // managed values
+    int nBufferMaxLen;
+    int nDepth;
+    int nPrevElement; // enum 0 -> start, 1 -> data, 2 -> end
+
+    //set and forget on creation
+    time_t nSearchTime;
+    FILE * pbOutfile;
+} TDNFFilterData;
+
+#define TDNF_MAX_FILTER_INPUT_THRESHOLD 10000000
+
+#define BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError) \
+    do {                                                           \
+        if (dwError)                                               \
+        {                                                          \
+            goto error;                                            \
+        }                                                          \
+    } while(0)
+
 #endif /* __SOLV_DEFINES_H__ */
diff --git a/solv/includes.h b/solv/includes.h
index 2ab0c5c..1e39ecb 100644
--- a/solv/includes.h
+++ b/solv/includes.h
@@ -10,7 +10,6 @@
 #include <unistd.h>
 #include <stdbool.h>
 #include <sys/types.h>
-#include <sys/stat.h>
 #include <dirent.h>
 
 // libsolv
@@ -44,4 +43,9 @@
 #include "../history/history.h"
 #include "prototypes.h"
 
+#include <expat.h>
+#include <stdlib.h>
+#include <time.h>
+#include <string.h>
+
 #endif /* __SOLV_INCLUDES_H__ */
diff --git a/solv/prototypes.h b/solv/prototypes.h
index 2633b5e..45f8793 100644
--- a/solv/prototypes.h
+++ b/solv/prototypes.h
@@ -517,7 +517,8 @@ SolvReadYumRepo(
     const char *pszPrimary,
     const char *pszFilelists,
     const char *pszUpdateinfo,
-    const char *pszOther
+    const char *pszOther,
+    const char * pszRepoEpochLimit
     );
 
 uint32_t
diff --git a/solv/tdnfrepo.c b/solv/tdnfrepo.c
index c27b907..17ea8bc 100644
--- a/solv/tdnfrepo.c
+++ b/solv/tdnfrepo.c
@@ -9,6 +9,639 @@
 
 #include "includes.h"
 
+// #### XML FILTER CODE ####
+uint32_t 
+checkAndResizeBuffer(char ** ppszCharBuffer, int * pnBufferMaxLen, int nLengthToAdd) {
+    uint32_t dwError = 0;
+    if (*pnBufferMaxLen <= 0 || nLengthToAdd < 0) {
+        dwError = ERROR_TDNF_TIME_FILTER_GENERAL;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+
+    int nBufferContentLen = strlen(*ppszCharBuffer);
+    while (nBufferContentLen + nLengthToAdd >= *pnBufferMaxLen)
+    {
+        *pnBufferMaxLen *= 2;
+        char * pszTempCharBuffer = NULL;
+        pszTempCharBuffer = realloc(*ppszCharBuffer, *pnBufferMaxLen);
+        if (!pszTempCharBuffer)
+        {
+            dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+        //set expanded char buffer 
+        *ppszCharBuffer = pszTempCharBuffer;
+    }
+cleanup:
+    return dwError;
+error:
+    goto cleanup;
+}
+
+uint32_t
+xmlEscapeCharLinter(const char * pszStringToEscape, char ** ppszDestStr) {
+    uint32_t dwError = 0;
+    const char * amp = "&amp;";
+    const char * gt = "&gt;";
+    const char * lt = "&lt;";
+
+    int nDescLen = (strlen(pszStringToEscape) + 1); // add one for null char
+    char * pszLintedStr = malloc(nDescLen * sizeof(char));
+    if (!pszLintedStr)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+    bzero(pszLintedStr, nDescLen * sizeof(char));
+    int nOffset = 0;
+    int nLintedSize = nDescLen;
+
+    for (int i = 0; i < nDescLen; i++)
+    {
+        char * pszCharToAdd = NULL;
+        int nAddStrlen = 1;
+        switch (pszStringToEscape[i])
+        {
+            case '&':
+                pszCharToAdd = amp;
+                break;
+            case '>':
+                pszCharToAdd = gt;
+                break;
+
+            case '<':
+                pszCharToAdd = lt;
+                break;
+        }
+
+        //resize buffer if needed
+        if (pszCharToAdd != NULL)
+        {
+            nAddStrlen = strlen(pszCharToAdd);
+        }
+        dwError = checkAndResizeBuffer(&pszLintedStr, &nLintedSize, nAddStrlen);
+        if (dwError)
+        {
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+
+        // add linted char if needed
+        if (pszCharToAdd == NULL)
+        {
+            pszLintedStr[i + nOffset] = pszStringToEscape[i];
+        }
+        else
+        {
+            strcat(pszLintedStr, pszCharToAdd);
+            nOffset += nAddStrlen - 1; // minus 1 to account for the original space used by the character
+        }
+    }
+
+    // set Dest to linted string
+    *ppszDestStr = pszLintedStr;
+    
+cleanup:
+    return dwError;
+error:
+    goto cleanup;
+}
+
+uint32_t 
+addElementStartToBuffer(char * pszElementBuffer, int * nElementBufferMax, const char * pszElementName, const char ** ppszAttrs) {
+    uint32_t dwError = 0;
+    
+    char * pszLintedAttrVal = NULL;
+    char * pszTempBuffer = NULL;
+    dwError = checkAndResizeBuffer(&pszElementBuffer, nElementBufferMax, strlen(pszElementName) + 1);
+    if (dwError)
+    {
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+    sprintf(pszElementBuffer, "<%s", pszElementName);
+    for (int i = 0; ppszAttrs[i]; i += 2)
+    {
+        dwError = xmlEscapeCharLinter((char *)ppszAttrs[i+1], &pszLintedAttrVal);
+        if (dwError)
+        {
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+        int nTempBufferLen = strlen(pszLintedAttrVal) + strlen(ppszAttrs[i]) + 4;
+        dwError = checkAndResizeBuffer(&pszElementBuffer, nElementBufferMax, nTempBufferLen);
+        if (dwError)
+        {
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+        pszTempBuffer = malloc(sizeof(char) * (nTempBufferLen + 1));
+        if (!pszTempBuffer)
+        {
+            dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+        sprintf(pszTempBuffer, " %s=\"%s\"", ppszAttrs[i], pszLintedAttrVal);
+        strcat(pszElementBuffer, pszTempBuffer);
+        
+        // free temp variables
+        free(pszTempBuffer);
+        pszTempBuffer = NULL;
+        free(pszLintedAttrVal);
+        pszLintedAttrVal = NULL;
+    }
+    strcat(pszElementBuffer, ">");
+    
+cleanup:
+    if (pszLintedAttrVal)
+    {
+        free(pszLintedAttrVal);
+    }
+    if (pszTempBuffer)
+    {
+        free(pszTempBuffer);
+    }
+    return dwError;
+error:
+    goto cleanup;
+}
+
+uint32_t 
+addElementEndToBuffer(char * pszElementBuffer, int * nElementBufferMaxLen, const char * pszElementName) {
+    uint32_t dwError = 0;
+    dwError = checkAndResizeBuffer(&pszElementBuffer, nElementBufferMaxLen, strlen(pszElementName) + 3);
+    if (dwError)
+    {
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+    sprintf(pszElementBuffer, "</%s>", pszElementName);
+    
+cleanup:
+    return dwError;
+error:
+    goto cleanup;
+}
+
+uint32_t 
+printElementStartToFile(FILE * pbOutfile, const char * pszElementName, const char ** ppszAttrs) {
+    uint32_t dwError = 0;
+    int nStartElementBufferLength = 500;
+    char * pszStartElement = malloc(sizeof(char) * nStartElementBufferLength);
+    if (!pszStartElement)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+
+    dwError = addElementStartToBuffer(pszStartElement, &nStartElementBufferLength, pszElementName, ppszAttrs);
+    if (dwError)
+    {
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+    fprintf(pbOutfile, "%s", pszStartElement);
+
+cleanup:
+    if (pszStartElement)
+    {
+        free(pszStartElement);
+    }
+    return dwError;
+error:
+    goto cleanup;
+}
+
+uint32_t 
+printElementEndToFile(FILE* pbOutfile, const char * pszElementName) {
+    uint32_t dwError = 0;
+    int nEndElementBufferLength = 500;
+    char * pszEndElement = malloc(sizeof(char) * nEndElementBufferLength);
+    if (!pszEndElement)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+
+    dwError = addElementEndToBuffer(pszEndElement, &nEndElementBufferLength, pszElementName);
+    if (dwError)
+    {
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+    fprintf(pbOutfile, "%s", pszEndElement);
+
+cleanup:
+    if (pszEndElement)
+    {
+        free(pszEndElement);
+    }
+    return dwError;
+error:
+    goto cleanup;
+}
+
+void 
+TDNFFilterStartElement(void *userData, const char * name, const char ** attrs) {
+    uint32_t dwError = 0;
+    char * pszStartElementBuffer = NULL;
+    // load tracking data
+    TDNFFilterData * pTracking = (TDNFFilterData *)userData;
+    int nAddNewLineAfterStart = pTracking->nPrevElement == 0;
+    char szNewLineBuffer[2];
+    if (nAddNewLineAfterStart)
+    {
+        sprintf(szNewLineBuffer, "\n");
+    }
+    else
+    {
+        bzero(szNewLineBuffer, sizeof(szNewLineBuffer)); // don't assume memory zero'd
+    }
+
+    // increment depth
+    pTracking->nDepth += 1;
+    pTracking->nPrevElement = 0;
+
+    // new package to parse or currently parsing package info
+    if (strcmp(name, "package") == 0 || pTracking->nInPackage)
+    {
+        pTracking->nInPackage = 1;
+
+        // already found/checked time
+        if (pTracking->nTimeFound && pTracking->nPrintPackage)
+        {
+            fprintf(pTracking->pbOutfile, "%s", szNewLineBuffer);
+            dwError = printElementStartToFile(pTracking->pbOutfile, name, attrs);
+            if (dwError)
+            {
+                BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+            }
+        }
+        else
+        { // still checking for time
+            if (strcmp(name, "time") == 0)
+            {
+                // time found
+                // validate file epoch time
+                for (int i = 0; attrs[i]; i += 2)
+                {
+                    if (strcmp(attrs[i], "file") == 0)
+                    { 
+                        // file time is the time the package is published to the repo
+                        // when this is less than our search time, allow the package to be
+                        // printed to the temp repo file, otherwise the current package
+                        // can be discarded.
+                        errno = 0;
+                        char * pszEpochEnd = NULL;
+                        long nCurrentPackageTime = strtoll(attrs[i+1], pszEpochEnd, 10);
+                        if (errno || pszEpochEnd == attrs[i+1])
+                        {
+                            dwError = ERROR_TDNF_TIME_FILTER_PARSE;
+                            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+                        }
+                        pTracking->nPrintPackage = (nCurrentPackageTime <= pTracking->nSearchTime);
+                        pTracking->nTimeFound = 1;
+                    }
+                }
+                if (pTracking->nPrintPackage)
+                {
+                    // print buffer when time is found
+                    fprintf(pTracking->pbOutfile, "%s", pTracking->pszElementBuffer);
+                    fprintf(pTracking->pbOutfile, "%s", szNewLineBuffer);
+
+                    // print time element
+                    dwError = printElementStartToFile(pTracking->pbOutfile, name, attrs);
+                    if (dwError)
+                    {
+                        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+                    }
+                }
+            }
+            else if (!pTracking->nTimeFound)
+            {
+                // if we haven't found a time yet, the element must be stored
+                // add to file buffer
+                int nStartElementBufferSize = 500;
+                pszStartElementBuffer = malloc(sizeof(char) * nStartElementBufferSize);
+                if (!pszStartElementBuffer)
+                {
+                    dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+                    BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+                }
+
+                dwError = addElementStartToBuffer(pszStartElementBuffer, &nStartElementBufferSize, name, attrs);
+                if (dwError)
+                {
+                    BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+                }
+                int nLenToAdd = strlen(pszStartElementBuffer);
+                nLenToAdd += strlen(szNewLineBuffer); //+1 if newLine character present
+
+                dwError = checkAndResizeBuffer(&pszStartElementBuffer, &nStartElementBufferSize, strlen(szNewLineBuffer));
+                if (dwError)
+                {
+                    BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+                }
+                strcat(pszStartElementBuffer, szNewLineBuffer);
+                
+                dwError = checkAndResizeBuffer(&(pTracking->pszElementBuffer), &(pTracking->nBufferMaxLen), nLenToAdd);
+                if (dwError)
+                {
+                    BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+                }
+                strcat(pTracking->pszElementBuffer, pszStartElementBuffer);
+            }
+        }
+    }
+    else
+    { // not in a package or parsing a new package
+        fprintf(pTracking->pbOutfile, "%s", szNewLineBuffer);
+        // output line
+        dwError = printElementStartToFile(pTracking->pbOutfile, name, attrs);
+        if (dwError)
+        {
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+    }
+cleanup:
+    if (pszStartElementBuffer)
+    {
+        free(pszStartElementBuffer);
+    }
+    return;
+error:
+    pr_err("An error occurred during start element parsing with the following code: %u\n", dwError);
+    goto cleanup;
+}
+
+void 
+TDNFFilterEndElement(void * userData, const char * name) {
+    uint32_t dwError = 0;
+    char * pszElementBuffer = NULL;
+    // load tracking data
+    TDNFFilterData * pTracking = (TDNFFilterData *)userData;
+
+    // decrement depth
+    pTracking->nDepth -= 1;
+    pTracking->nPrevElement = 2;
+
+    if (!pTracking->nInPackage || pTracking->nPrintPackage)
+    {
+        // print end element to file
+        dwError = printElementEndToFile(pTracking->pbOutfile, name);
+        if (dwError)
+        {
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+
+    } 
+    else if (pTracking->nInPackage && !pTracking->nTimeFound)
+    {
+        int nEndElementBufferLen = 500;
+        pszElementBuffer = malloc(sizeof(char) * nEndElementBufferLen);
+        if (!pszElementBuffer)
+        {
+            dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+        // add end element to buffer
+        dwError = addElementEndToBuffer(pszElementBuffer, &nEndElementBufferLen, name);
+        if (dwError)
+        {
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+        int nEndElementLen = strlen(pszElementBuffer);
+
+        dwError = checkAndResizeBuffer(&(pTracking->pszElementBuffer), &(pTracking->nBufferMaxLen), nEndElementLen);
+        if (dwError)
+        {
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+        strcat(pTracking->pszElementBuffer, pszElementBuffer);
+
+    } // else do nothing
+
+    if (strcmp(name, "package") == 0)
+    { // on end package, reset tracking function
+        // reset userData
+        pTracking->nBufferLen = 0;
+        bzero(pTracking->pszElementBuffer, pTracking->nBufferMaxLen);
+        pTracking->nInPackage = 0;
+        pTracking->nPrintPackage = 0;
+        pTracking->nTimeFound = 0;
+    }
+cleanup:
+    if (pszElementBuffer)
+    {
+        free(pszElementBuffer);
+    }
+    return;
+error:
+    pr_err("An error occurred during end element parsing with the following code: %u\n", dwError);
+    goto cleanup;
+}
+
+void 
+TDNFFilterCharDataHandler(void * userData, const char * content, int length) {
+    uint32_t dwError = 0;
+    // load tracking data
+    TDNFFilterData * pTracking = (TDNFFilterData *)userData;
+    pTracking->nPrevElement = 1;
+
+    char * pszCharData = malloc((length + 1) * sizeof(char));
+    if (!pszCharData)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+    bzero(pszCharData, (length + 1) * sizeof(char));
+    strncpy(pszCharData, content, length);
+    char * pszLintedCharData = NULL;
+    dwError = xmlEscapeCharLinter(pszCharData, &pszLintedCharData);
+    if (dwError)
+    {
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+
+    // check params 
+    if (!pTracking->nInPackage || pTracking->nPrintPackage)
+    {
+        // print to file
+        fprintf(pTracking->pbOutfile, "%s", pszLintedCharData);
+    }
+    else if (pTracking->nInPackage && !pTracking->nTimeFound)
+    {
+        // add to buffer
+        dwError = checkAndResizeBuffer(&(pTracking->pszElementBuffer), &(pTracking->nBufferMaxLen), strlen(pszLintedCharData));
+        if (dwError)
+        {
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+        strcat(pTracking->pszElementBuffer, pszLintedCharData);
+    } // else do nothing (skipped package)
+
+cleanup:
+    if (pszLintedCharData)
+    {
+        free(pszLintedCharData);
+    }
+    if (pszCharData)
+    {
+        free(pszCharData);
+    }
+    return;
+error:
+    pr_err("An error occurred during char data handling with the following code: %u\n", dwError);
+    goto cleanup;
+}
+
+char * 
+TDNFFilterFile(const char * pszInFilePath, const char * pszEpochTime) {
+    // vars
+    uint32_t dwError = 0;
+    TDNFFilterData pData;
+    bzero(&pData, sizeof(TDNFFilterData));
+    time_t nEpochTime;
+    bzero(&nEpochTime, sizeof(time_t));
+    XML_Parser bParser;
+    bzero(&bParser, sizeof(XML_Parser));
+    FILE * pbInFile = NULL;
+    FILE * pbOutFile = NULL;
+    char pszTimeExtension[100];
+    char * pszOutFilePath = NULL;
+
+    // convert epoch string to time for use by the parser and the temp file name
+    errno = 0;
+    char * pszEpochEnd = NULL;
+    nEpochTime = strtoll(pszEpochTime, &pszEpochEnd, 10);
+    if (errno || pszEpochEnd == pszEpochTime)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_PARSE;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+
+    //create output file ending
+    sprintf(pszTimeExtension, "-%lld.xml", nEpochTime);
+
+    // find total extension length
+    int nInFileExtLen = 4; // len of ".xml"
+    char * pszFileExt = strrchr(pszInFilePath, '.');
+    if (strcmp(pszFileExt, ".xml") != 0)
+    {
+        nInFileExtLen += strlen(pszFileExt);
+    }
+
+    // calculate outfile length and allocate
+    int nInFileLen = strlen(pszInFilePath);
+    int nOutFileLen = (nInFileLen - nInFileExtLen) + strlen(pszTimeExtension) + 1;
+    pszOutFilePath = malloc(nOutFileLen * sizeof(char));
+    if (!pszOutFilePath)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+    bzero(pszOutFilePath, nOutFileLen * sizeof(char));
+
+    // use infile path + timestamp as new output file
+    strncpy(pszOutFilePath, pszInFilePath, nInFileLen - nInFileExtLen); // remove extension to be added with the name
+    strcat(pszOutFilePath, pszTimeExtension);
+
+    // init vars, load files
+    pbInFile = solv_xfopen(pszInFilePath, "r");
+    if (!pbInFile)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_IO;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+    pbOutFile = fopen(pszOutFilePath, "w");
+    if (!pbOutFile)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_IO;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+
+    pData.nBufferMaxLen = 5000; // arbitrary number, 5000 is likely sufficient in most scenarios but is resized if required
+    pData.pszElementBuffer = (char *)malloc(pData.nBufferMaxLen * sizeof(char));
+    if (!pData.pszElementBuffer)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+    bzero(pData.pszElementBuffer, pData.nBufferMaxLen);
+    pData.pbOutfile = pbOutFile;
+    pData.nSearchTime = nEpochTime;
+    pData.nDepth = 0;
+    pData.nBufferLen = 0;
+    pData.nInPackage = 0;
+    pData.nPrintPackage = 0;
+    pData.nTimeFound = 0;
+
+    //create parser
+    bParser = XML_ParserCreate(NULL);
+    if (!bParser)
+    {
+        dwError = ERROR_TDNF_TIME_FILTER_PARSE;
+        BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+    }
+
+    XML_SetUserData(bParser, &pData);
+    XML_SetElementHandler(bParser, TDNFFilterStartElement, TDNFFilterEndElement);
+    XML_SetCharacterDataHandler(bParser, TDNFFilterCharDataHandler);
+
+    //parse XML
+    fprintf(pbOutFile, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
+    int nInputEof;
+    do
+    {
+        void * pszXMLParseBuffer = XML_GetBuffer(bParser, BUFSIZ);
+        if (!pszXMLParseBuffer)
+        {
+            fprintf(stderr, "Couldn't allocate memory for buffer\n");
+            dwError = ERROR_TDNF_TIME_FILTER_MEMORY;
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+
+        const size_t len = fread(pszXMLParseBuffer, 1, BUFSIZ - 1, pbInFile);
+        ((char *)pszXMLParseBuffer)[len] = '\0';
+        if (ferror(pbInFile))
+        {
+            dwError = ERROR_TDNF_TIME_FILTER_PARSE;
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+
+        nInputEof = feof(pbInFile);
+
+        if (XML_ParseBuffer(bParser, (int)len, nInputEof) == XML_STATUS_ERROR)
+        {
+            fprintf(stderr,
+                "Parse error at line %lu:\n%s\n",
+                XML_GetCurrentLineNumber(bParser),
+                XML_ErrorString(XML_GetErrorCode(bParser)));
+            dwError = ERROR_TDNF_TIME_FILTER_PARSE;
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+    } while (!nInputEof);
+
+cleanup:
+    if (pData.pszElementBuffer) {
+        free(pData.pszElementBuffer);
+    }
+
+    if (bParser)
+    {
+        XML_ParserFree(bParser);
+    }
+
+    if (pbOutFile)
+    {
+        fclose(pbOutFile);
+    }
+
+    if (pbInFile)
+    {
+        fclose(pbInFile);
+    }
+
+    return pszOutFilePath;
+error:
+    pr_err("An error occurred during epoch time filtering with the following code: %u\n", dwError);
+    goto cleanup;
+}
+// #### END XML FILTER CODE ####
+
 uint32_t
 SolvLoadRepomd(
     Repo* pRepo,
@@ -195,10 +828,14 @@ SolvReadYumRepo(
     const char *pszPrimary,
     const char *pszFilelists,
     const char *pszUpdateinfo,
-    const char *pszOther
+    const char *pszOther,
+    const char * pszRepoEpochLimit
     )
 {
     uint32_t dwError = 0;
+    // new vars for Filter
+    char * tempPrimaryRepoFile = NULL;
+    // end new vars
     if(!pRepo || !pszRepoName || !pszRepomd || !pszPrimary)
     {
         dwError = ERROR_TDNF_INVALID_PARAMETER;
@@ -209,6 +846,18 @@ SolvReadYumRepo(
     BAIL_ON_TDNF_LIBSOLV_ERROR(dwError);
 
 
+    // Run filter if option present
+    if (pszRepoEpochLimit != NULL){
+        tempPrimaryRepoFile = TDNFFilterFile(pszPrimary, pszRepoEpochLimit);
+        if (tempPrimaryRepoFile == NULL)
+        {
+            dwError = ERROR_TDNF_TIME_FILTER_GENERAL;
+            BAIL_ON_TDNF_TIME_FILTER_ERROR(dwError);
+        }
+        pszPrimary = tempPrimaryRepoFile;
+    }
+    // End filter code
+
     dwError = SolvLoadRepomdPrimary(pRepo, pszPrimary);
     BAIL_ON_TDNF_LIBSOLV_ERROR(dwError);
 
@@ -232,6 +881,11 @@ SolvReadYumRepo(
 
 
 cleanup:
+    if(tempPrimaryRepoFile != NULL)
+    {
+        remove(tempPrimaryRepoFile);
+        free(tempPrimaryRepoFile);
+    }
 
     return dwError;
 
diff --git a/tools/cli/lib/help.c b/tools/cli/lib/help.c
index bc4cf83..9c6407f 100644
--- a/tools/cli/lib/help.c
+++ b/tools/cli/lib/help.c
@@ -23,6 +23,7 @@ static const char *help_msg =
  "           [--downloadonly]\n"
  "           [--enablerepo=<repoid>]\n"
  "           [--enableplugin=<plugin_name>]\n"
+ "           [--epochtimelimit=<epoch_time>]\n"
  "           [--exclude [file1,file2,...]]\n"
  "           [--installroot [path]]\n"
  "           [--noautoremove]\n"
diff --git a/tools/cli/lib/parseargs.c b/tools/cli/lib/parseargs.c
index 0558611..0e3469d 100644
--- a/tools/cli/lib/parseargs.c
+++ b/tools/cli/lib/parseargs.c
@@ -44,6 +44,7 @@ static struct option pstOptions[] =
     {"downloadonly",  no_argument, &_opt.nDownloadOnly, 1}, //--downloadonly
     {"enableplugin",  required_argument, 0, 0},            //--enableplugin
     {"enablerepo",    required_argument, 0, 0},            //--enablerepo
+    {"epochtimelimit",required_argument, 0, 0},            //--epochtimelimit
     {"exclude",       required_argument, 0, 0},            //--exclude
     {"help",          no_argument, 0, 'h'},                //-h --help
     {"installroot",   required_argument, 0, 'i'},          //--installroot
-- 
2.34.1

